# -*- coding: utf-8 -*-
"""CO_project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1B1zDL9uisc8X5eqcfzH-zSKYJsYccv9Y
"""

# does not work for labels and memory addresses,variables
def check_instruction_A(instruction_list): # checks if instruction is of type A then returns 0
  if (len(instruction_list)==4) and (instruction_list[0] in available_commands) and (instruction_list[1] in registers) and (instruction_list[2] in registers) and (instruction_list[3] in registers):
    return 0
  return 1
def check_instruction_B(instruction_list): # checks if instruction is of type B then returns 0
  try:
    int(instruction_list[2][1:])
  except:
    return 1
  if (len(instruction_list)==3) and (instruction_list[0] in available_commands) and (instruction_list[1] in registers) and (0<=int(instruction_list[2][1:])<=127):
    return 0
  return 1
def check_instruction_C(instruction_list): # checks if instruction is of type C then returns 0.....see implmentation for mem_address!
  if (len(instruction_list)==3) and (instruction_list[0] in available_commands) and (instruction_list[1] in registers) and (instruction_list[2] in registers):
    return 0
  return 1
def check_instruction_D(instruction_list): # checks if instruction is of type D then returns 0
  try:
    int(instruction_list[2][1:])
  except:
    return 1
  if (len(instruction_list)==3) and (instruction_list[0] in available_commands) and (instruction_list[1] in registers):
    return 0
  return 1
def check_instruction_E(instruction_list): # checks if instruction is of type E then returns 0
  if (len(instruction_list)==2) and (instruction_list[0] in available_commands) and (int(instruction_list[1])):
    return 0
  return 1
def check_instruction_F(instruction_list): # checks if instruction is of type F then returns 0
  if instruction_list==['hlt']:
    return 0
  return 1
'''def check_variables(command_list):
  for i in range(len(command_list)):'''

f=open("/Untitled Document 1",'r')
command_list=f.readlines()
output=open("output_file.txt",'w')
for i in range(len(command_list)):
  command_list[i]=command_list[i].split()
print(command_list)  #will give the lines broken up into seperate words and gives empty lists for empty lines
l=len(command_list)
available_commands=['add','sub','mov','ld','st','mul','div','rs','ls','xor','or','and','not','cmp','jmp','jlt','jgt','je','hlt']
registers=['R0','R1','R2','R3','R4','R5','R6','FLAGS']
for i in range(len(l)): #starting to check for conditions
  if command_list[i]!=[]: # checks for condition a
    if check_instruction_A(command_list[i]) and  check_instruction_B(command_list[i]) and check_instruction_C(command_list[i]) and check_instruction_D(command_list[i]) and check_instruction_E(command_list[i]) and check_instruction_F(command_list[i]):
      s=f"{i+1} incorrect instruction name or register name"
      print(s)
      #f.write(s)

      continue
if ['hlt'] not in command_list: # condition h
  print(f'{len(l)} hlt is missing')
if ['hlt'] in command_list and ['hlt']!=command_list[l-1]:# condition i
  print(f'{l} hlt is not last instruction')



f.close()
