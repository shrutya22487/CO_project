i , R0 , R1 , R2 , R3 , R4 , R5 , R6 , FLAGS =0, 0 , 0 , 0 , 0 , 0 , 0 , 0 , '0000000000000000'
reg = { "000" : R0 , "001" : R1 , "010" : R2 , "011" : R3 , "100" : R4 , "101" : R5 , "110" : R6 , "111" : FLAGS }  
command_list=["0001000100000100", "0011100000001110", "1101000000000000"]
l = len ( command_list )
variables = [] 
def registers():
    s=''
    for j in reg:
        if j!="111":
            s+=binary(reg[j],16) + '\n' #gives the output of the registers as binary 16 bits
    s+=FLAGS
    return s
def binary(x,n): #x->Decimal number, n->No of bits
    lst=["0" for i in range (n)]
    for i in range (n-1, -1, -1):
        lst[i]=str(x%2)
        x=x//2
    return "".join(lst)
def decimal(n): # converts from binary to decimal
    num, value , base = int( n ) , 0 , 1 
    tmp = num
    while( tmp != 0 ):
        l = tmp % 10
        tmp = tmp // 10
        value = value + l * base
        base *= 2
    return value
def add(instr):
    global FLAGS
    reg2=binary(reg[instr[10:13]],16)
    reg3=binary(reg[instr[13:]],16)
    reg1=binary(reg[instr[7:10]],16)
    reg[reg1] = reg2 + reg3
    reg4 = decimal(reg[reg1])
    if reg4 > (2**16 -1) or reg4 < -(2**16):
        FLAGS="0000000000001000"
        reg[reg1] = binary(0,16)
    else:
        FLAGS="0000000000000000"
    
    return i+1

def sub(instr):
    global FLAGS
    reg2=reg[instr[10:13]]
    reg3=reg[instr[13:]]
    reg1=reg[instr[7:10]]
    reg[reg1] = reg2 - reg3
    if reg[reg2] < reg[reg3]:
        FLAGS="0000000000001000"
        reg[reg1] = binary(0,16)
    else:
        FLAGS="0000000000000000"
    
    return i+1

def mul(instr):
    global FLAGS
    reg2=binary(reg[instr[10:13]],16)
    reg3=binary(reg[instr[13:]],16)
    reg1=binary(reg[instr[7:10]],16)
    reg[reg1] = reg2 * reg3
    reg4 = decimal(reg[reg1])
    if reg4 > (2**16 -1) or reg4 < -(2**16):
        FLAGS="0000000000001000"
        reg[reg1] = binary(0,16)
    else:
        FLAGS="0000000000000000"
    
    return i+1

def bit_xor(instr):
    global FLAGS
    reg2=reg[instr[10:13]]
    reg3=reg[instr[13:]]
    reg1=reg[instr[7:10]]
    reg[reg1] = reg2 ^ reg3
    return i+1

def bit_or(instr):
    global FLAGS
    reg2=reg[instr[10:13]]
    reg3=reg[instr[13:]]
    reg1=reg[instr[7:10]]
    reg[reg1] = reg2 | reg3
    return i+1

def bit_and(instr):
    global FLAGS
    reg2=reg[instr[10:13]]
    reg3=reg[instr[13:]]
    reg1=reg[instr[7:10]]
    reg[reg1] = reg2 & reg3
    return i+1
def hlt():
    return 0

command_list=["0001000100000100", "0011100000001110", "1101000000000000"]


instructions = { "00000" : add
                , "00001" : sub
                , "00110" : mul
                , "01010" : bit_xor
                , "01011" : bit_or
                , "01100" : bit_and
                , "11010" : hlt()
                }

while ( command_list[i][:5]!='11010'):   #termination step is when we reach opcode of halt
    i=instructions[command_list[i][:5]](command_list[i])
    s=registers()
    print(binary(i,7)+"\n"+s+"\n\n")
